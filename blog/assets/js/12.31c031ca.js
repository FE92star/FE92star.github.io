(window.webpackJsonp=window.webpackJsonp||[]).push([[12],{180:function(_,v,e){"use strict";e.r(v);var t=e(0),a=Object(t.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var _=this,v=_.$createElement,e=_._self._c||v;return e("div",{staticClass:"content"},[e("h1",{attrs:{id:"js基础知识"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#js基础知识","aria-hidden":"true"}},[_._v("#")]),_._v(" JS基础知识")]),_._v(" "),e("h2",{attrs:{id:"q1：script标签的属性"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#q1：script标签的属性","aria-hidden":"true"}},[_._v("#")]),_._v(" Q1：script标签的属性")]),_._v(" "),e("ul",[e("li",[_._v("script是用来引入JS代码的html标签，包含以下属性：\n"),e("ol",[e("li",[e("code",[_._v("type")]),_._v("：表示编写代码使用的脚本语言的内容类型，默认都是"),e("code",[_._v("text/javascript")]),_._v("；")]),_._v(" "),e("li",[e("code",[_._v("src")]),_._v("：用于表示引入外部脚本的链接地址；")]),_._v(" "),e("li",[e("code",[_._v("defer")]),_._v("和"),e("code",[_._v("async")]),_._v("：都是指引入的外部脚本会异步加载，防止阻塞html的解析，区别在于"),e("code",[_._v("defer")]),_._v("表示的是等待执行，即等整个页面加载结束之后再执行，虽然已经被异步加载；"),e("code",[_._v("async")]),_._v("则表示再不影响页面解析和其他脚本执行的情况下，立即下载该脚本代码；")])])])]),_._v(" "),e("h2",{attrs:{id:"q2：js的数据类型"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#q2：js的数据类型","aria-hidden":"true"}},[_._v("#")]),_._v(" Q2：JS的数据类型")]),_._v(" "),e("ul",[e("li",[_._v("包含基本类型和引用类型")])]),_._v(" "),e("ol",[e("li",[_._v("基本类型："),e("code",[_._v("boolean")]),_._v(","),e("code",[_._v("string")]),_._v(","),e("code",[_._v("number")]),_._v(","),e("code",[_._v("null")]),_._v(","),e("code",[_._v("undefined")]),_._v(",引用类型："),e("code",[_._v("object")])]),_._v(" "),e("li",[_._v("区别在于：基本类型的变量赋值时完全赋值的，新的变量具有和赋值变量不同的内存空间，而引用类型在赋值的时候，是将对象的指针赋值给新变量，没有新开内存空间，因此指向的还是同一个堆内存中的对象，对新变量的操作会反应到赋值对象上面；")]),_._v(" "),e("li",[_._v("上面的现象的原因：基本类型的变量是存储在栈内存中，而引用类型的指针是存储在栈中，而指向的是存储在堆内存中的真正的对象；")])]),_._v(" "),e("h2",{attrs:{id:"q3：js的执行机理（延申到作用域，作用域链，执行上下文）"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#q3：js的执行机理（延申到作用域，作用域链，执行上下文）","aria-hidden":"true"}},[_._v("#")]),_._v(" Q3：JS的执行机理（延申到作用域，作用域链，执行上下文）")]),_._v(" "),e("ul",[e("li",[_._v("JS是"),e("code",[_._v("单线程语言")]),_._v("，代码的执行顺序是从上到下依次执行，代码的执行是发生在"),e("code",[_._v("执行环境栈")]),_._v("（Ectack）中，可以类比成一个"),e("code",[_._v("加工厂")]),_._v("，所有的JS代码都必须经过工厂的加工处理，原理如下：\n"),e("ol",[e("li",[_._v("JS代码进入执行栈加工厂中，首先初始化全局环境"),e("code",[_._v("window")]),_._v("，将全局环境压至栈底，并会生成一个全局变量对象，并在整个JS生命周期中一直存在，")]),_._v(" "),e("li",[_._v("执行函数A，A进入栈顶，并初始化A的执行上下文，执行上下文包含3个部分：变量对象（函数为活动对象），作用域链，this指向；变量对象包含：arguments对象，函数声明和变量声明；\n执行结束之后，A的执行上下文被弹出，进入下一个函数的执行环节；")]),_._v(" "),e("li",[_._v("上述过程总结：作用域是指对变量的引用的权限")])])])]),_._v(" "),e("h2",{attrs:{id:"q4：基于原型链的继承方式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#q4：基于原型链的继承方式","aria-hidden":"true"}},[_._v("#")]),_._v(" Q4：基于原型链的继承方式")]),_._v(" "),e("ul",[e("li",[_._v("原型链：每一个函数（对象）都有一个"),e("code",[_._v("prototype")]),_._v("属性，这是一个原型对象，里面包含了源对象的所有属性和方法，同时它有一个"),e("code",[_._v("constructor")]),_._v("属性，指向构造函数本身，利用构造函数"),e("code",[_._v("new")]),_._v("出来的实例，有一个"),e("code",[_._v("_proto_")]),_._v("属性，其是一个指针指向的是构造函数的"),e("code",[_._v("prototype")]),_._v("属性，让构造函数的原型对象等于另外一个类型的实例，此时此原型对象就包含指向另一个原型的指针，层层递进，就构成了"),e("code",[_._v("实例")]),_._v("和"),e("code",[_._v("原型")]),_._v("的链条，原型链的顶端指向的是"),e("code",[_._v("null")]),_._v("对象")])])])}],!1,null,null,null);v.default=a.exports}}]);